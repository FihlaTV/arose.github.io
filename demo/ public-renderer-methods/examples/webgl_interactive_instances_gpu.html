<!DOCTYPE html>
<html lang="en">
	<head>
		<title>three.js webgl - interactive instances (gpu)</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			body {
				font-family: Monospace;
				background-color: #f0f0f0;
				margin: 0px;
				overflow: hidden;
			}

			.info {
				position: absolute;
				background-color: black;
				opacity: 0.8;
				color: white;
				text-align: center;
				top: 0px;
				width: 100%;
			}

			.info a {
				color: #00ffff;
			}
		</style>
	</head>
	<body>

		<div class="info">
			<a href="http://threejs.org" target="_blank">three.js</a> webgl - gpu picking of geometry instances using a single material
		</div>

		<div id="container"></div>

		<script src="../build/three.min.js"></script>

		<script src="../src/renderers/WebGLRenderer.js"></script>

		<script src="js/controls/TrackballControls.js"></script>

		<script src="js/libs/stats.min.js"></script>

		<script id="vertexShader" type="x-shader/x-vertex">

			precision mediump float;
			precision mediump int;

			uniform mat4 modelViewMatrix;
			uniform mat4 projectionMatrix;

			attribute vec3 position;

			void main()	{

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script id="fragmentShader" type="x-shader/x-fragment">

			precision mediump float;
			precision mediump int;

			uniform vec3 pickingColor;

			void main()	{

				gl_FragColor.xyz = pickingColor;

			}

		</script>

		<script>

			var container, stats;
			var camera, controls, scene, renderer;
			var pickingData = [], pickingTexture, pickingScene;
			var objects = [];
			var highlightBox;

			var mouse = new THREE.Vector2();
			var scale = new THREE.Vector3( 1.1, 1.1, 1.1 );

			//create buffer for reading single pixel
			var pixelBuffer = new Uint8Array( 4 );

			init();
			animate();

			function init() {

				container = document.getElementById( "container" );

				camera = new THREE.PerspectiveCamera(
					70, window.innerWidth / window.innerHeight, 1, 10000
				);
				camera.position.z = 500;

				//

				scene = new THREE.Scene();

				pickingScene = new THREE.Scene();
				pickingTexture = new THREE.WebGLRenderTarget(
					window.innerWidth, window.innerHeight
				);
				pickingTexture.generateMipmaps = false;

				//

				var material = new THREE.MeshNormalMaterial( {
					shading: THREE.SmoothShading
				} );

				var pickingMaterial = new THREE.RawShaderMaterial( {

					uniforms: {
						pickingColor: { type: "c", value: new THREE.Color() }
					},
					vertexShader: document.getElementById( 'vertexShader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentShader' ).textContent

				} );

				//

				highlightBox = new THREE.Mesh(

					new THREE.BoxGeometry( 1, 1, 1 ),
					new THREE.MeshLambertMaterial( {
						color: 0xffff00,
						transparent: true,
						opacity: 0.5
					}

				) );
				scene.add( highlightBox );

				var loader = new THREE.JSONLoader();
				loader.load( 'obj/Suzanne.js', function ( geometry ) {

					geometry.computeBoundingBox();
					var size = geometry.boundingBox.size();

					highlightBox.geometry = new THREE.BoxGeometry(
						size.x, size.y, size.z
					);

					for ( var i = 0; i < 2000; i ++ ) {

						var object = new THREE.Mesh( geometry, material );

						object.position.x = Math.random() * 800 - 400;
						object.position.y = Math.random() * 800 - 400;
						object.position.z = Math.random() * 800 - 400;

						object.rotation.x = Math.random() * 2 * Math.PI;
						object.rotation.y = Math.random() * 2 * Math.PI;
						object.rotation.z = Math.random() * 2 * Math.PI;

						object.scale.x = object.scale.y = object.scale.z = Math.random() * 30;

						scene.add( object );

						//

						pickingData[ i + 1 ] = object;

						var pickingObject = object.clone();
						pickingObject.material = pickingMaterial;
						pickingObject.userData[ "pickingColor" ] = i + 1;

						pickingScene.add( pickingObject );

					}

				} );

				//

				renderer = new THREE.WebGLRenderer( {
					antialias: true,
					alpha: true
				} );
				renderer.setClearColor( 0xffffff );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.sortObjects = false;
				container.appendChild( renderer.domElement );

				// patch the renderer to change the material's uniforms
				// on a per object basis while using only a single material

				var originalSetProgram = renderer.setProgram;

				renderer.setProgram = function ( camera, lights, fog, material, object ) {

					var program = originalSetProgram( camera, lights, fog, material, object );

					//

					var pickingColorValue = object.userData[ "pickingColor" ];

					if( pickingColorValue && material.uniforms ){

						material.uniforms[ "pickingColor" ].value.setHex(
							pickingColorValue
						);

						renderer.loadUniformsGeneric( material.uniformsList );

					}

					return program;

				};

				//

				controls = new THREE.TrackballControls(
					camera, renderer.domElement
				);
				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;
				controls.noZoom = false;
				controls.noPan = false;
				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				//

				stats = new Stats();
				stats.domElement.style.position = 'absolute';
				stats.domElement.style.top = '0px';
				container.appendChild( stats.domElement );

				renderer.domElement.addEventListener( 'mousemove', onMouseMove );

			}

			//

			function onMouseMove( e ) {

				mouse.x = e.clientX;
				mouse.y = e.clientY;

			}

			function animate() {

				requestAnimationFrame( animate );

				render();

				controls.update();
				stats.update();

			}

			function pick() {

				// render the picking scene off-screen

				renderer.render( pickingScene, camera, pickingTexture );

				// read the pixel under the mouse from the texture

				renderer.readRenderTargetPixels(
					pickingTexture,
					mouse.x,
					pickingTexture.height - mouse.y,
					1,
					1,
					pixelBuffer
				);

				// interpret the pixel as an ID

				var id =
					( pixelBuffer[0] << 16 ) |
					( pixelBuffer[1] << 8 ) |
					( pixelBuffer[2] );

				var object = pickingData[ id ];

				if ( object ) {

					//move the highlightBox so that it surrounds the picked object

					if ( object.position && object.rotation && object.scale ){

						highlightBox.position.copy( object.position );
						highlightBox.rotation.copy( object.rotation );
						highlightBox.scale.copy( object.scale ).multiply( scale );
						highlightBox.visible = true;

					}

				} else {

					highlightBox.visible = false;

				}

			}

			function render() {

				pick();
				renderer.render( scene, camera );

			}

		</script>

	</body>
</html>
